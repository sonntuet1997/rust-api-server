use std::sync::Arc;

use tonic::{Request, Response, Status};
use tracing::instrument;

use common::grpc::gpt_answer::gpt_answer::{
    gpt_answer_service_server::GptAnswerService, GetAnswerPayload, GetAnswerResponse,
};
use rust_core::{common::errors::CoreError, ports::cache::CachePort};

/// Implementation of the gRPC service for generating answers to questions.
///
/// This struct represents the gRPC server implementation for answering questions. It implements
/// the `GptAnswerService` trait generated by Tonic, which defines the RPC methods for answering
/// questions.
pub struct GptAnswerServiceImpl {
    pub cache: Arc<dyn CachePort + Sync + Send>,
}

impl GptAnswerServiceImpl {
    pub fn new(cache: Arc<dyn CachePort + Sync + Send>) -> Self {
        Self { cache }
    }
}

#[tonic::async_trait]
impl GptAnswerService for GptAnswerServiceImpl {
    /// Handle the gRPC `get_answer` request.
    ///
    /// This method is called when a gRPC client sends a request to get an answer to a question.
    /// It receives a request containing the question payload and generates an answer based on
    /// the received question. The logic for generating the answer is yet to be implemented.
    ///
    /// # Arguments
    ///
    /// * `request`: A `Request` containing the `GetAnswerPayload` with the question.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `Response` with the `GetAnswerResponse` containing the
    /// generated answer if successful. If there's an error during processing, it returns a
    /// `Status` indicating the error.
    #[instrument(level = "info", skip(self))]
    async fn get_answer(
        &self,
        request: Request<GetAnswerPayload>,
    ) -> Result<Response<GetAnswerResponse>, Status> {
        // Extract the payload containing the question from the request
        let payload = request.into_inner();

        let answer = match self.cache.get(&payload.question).await {
            Ok(answer) => answer,
            Err(err) => {
                if let CoreError::NotFound = err {
                    // Set a default answer to cache
                    let default_answer = String::from("This is a default answer");
                    self.cache
                        .set(&payload.question.clone(), &default_answer.clone(), None)
                        .await
                        .map_err(|err| {
                            Status::internal(format!("failed to get answer from cache: {}", err))
                        })?;
                    default_answer
                } else {
                    return Err(Status::internal(format!(
                        "failed to get answer from cache: {}",
                        err
                    )));
                }
            }
        };

        // Construct a response containing the generated answer
        let response = GetAnswerResponse { answer };

        // Return the response
        Ok(Response::new(response))
    }
}
