use tonic::{Request, Response, Status};

use common::{
    grpc::gpt_answer::gpt_answer::{
        gpt_answer_service_server::GptAnswerService, GetAnswerPayload, GetAnswerResponse,
    },
    redis::redis::Redis,
};

/// Implementation of the gRPC service for generating answers to questions.
///
/// This struct represents the gRPC server implementation for answering questions. It implements
/// the `GptAnswerService` trait generated by Tonic, which defines the RPC methods for answering
/// questions.
pub struct GptAnswerServiceImpl {
    pub redis_client: Redis,
}

impl GptAnswerServiceImpl {
    pub fn new(redis_client: Redis) -> Self {
        Self { redis_client }
    }
}

#[tonic::async_trait]
impl GptAnswerService for GptAnswerServiceImpl {
    /// Handle the gRPC `get_answer` request.
    ///
    /// This method is called when a gRPC client sends a request to get an answer to a question.
    /// It receives a request containing the question payload and generates an answer based on
    /// the received question. The logic for generating the answer is yet to be implemented.
    ///
    /// # Arguments
    ///
    /// * `request`: A `Request` containing the `GetAnswerPayload` with the question.
    ///
    /// # Returns
    ///
    /// Returns a `Result` containing a `Response` with the `GetAnswerResponse` containing the
    /// generated answer if successful. If there's an error during processing, it returns a
    /// `Status` indicating the error.
    async fn get_answer(
        &self,
        request: Request<GetAnswerPayload>,
    ) -> Result<Response<GetAnswerResponse>, Status> {
        // Extract the payload containing the question from the request
        let payload = request.into_inner();

        // TODO: Implement your logic to generate an answer based on the question.
        // Placeholder logic: Generate an answer string
        let mut answer = match self.redis_client.get(&payload.question).await {
            Ok(Some(cached_answer)) => Some(cached_answer),
            Err(err) => {
                return Err(Status::internal(format!(
                    "Error getting answer from Redis: {}",
                    err
                )));
            }
            _ => None,
        };

        // If answer not found in Redis, generate it and cache it
        if answer.is_none() {
            answer = Some(format!("Answer to: {}", payload.question));
            if let Err(err) = self
                .redis_client
                .set(&payload.question, &answer.clone().unwrap())
                .await
            {
                return Err(Status::internal(format!(
                    "Error caching answer in Redis: {}",
                    err
                )));
            }
        }

        // Construct a response containing the generated answer
        let response = GetAnswerResponse {
            answer: answer.unwrap(),
        };

        // Return the response
        Ok(Response::new(response))
    }
}
